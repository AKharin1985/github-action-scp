#!/usr/bin/env node
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const billy_core_1 = require("@fivethree/billy-core");
const billy_plugin_core_1 = require("@fivethree/billy-plugin-core");
const billy_plugin_git_1 = require("@fivethree/billy-plugin-git");
const core = __importStar(require("@actions/core"));
const params_1 = require("./params");
const promise_1 = __importDefault(require("simple-git/promise"));
let GithubActionsPlugin = class GithubActionsPlugin {
    release(branch = "release") {
        return __awaiter(this, void 0, void 0, function* () {
            const status = yield this.git_status();
            const origin = status.tracking.split("/")[0];
            const clean = yield this.checkRepoClean(origin, status);
            const json = yield this.parseJSON("package.json");
            const gitignore = yield this.readFile(".gitignore");
            branch = `${branch}/${json.version}`;
            if (!clean) {
                return;
            }
            yield this.switchToBranch(status, branch);
            if (gitignore.indexOf("!node_modules") === -1) {
                yield this.writeFile(".gitignore", gitignore.replace("node_modules", "!node_modules"));
            }
            yield this.exec("npm run build", true);
            yield this.exec("npm prune --production && git add node_modules/*");
            console.log("release version", json.version);
            yield this.exec("git add .", true);
            yield this.exec(`git commit -a -m "Publishing version ${json.version}"`, true);
            const remote = yield this.getRemoteBranch(origin, branch);
            console.log(remote
                ? `Pushing to remote ${origin}/${branch}`
                : `Creating remote ${origin}/${branch}`);
            if (remote) {
                yield this.exec(`git push ${origin} ${branch}`, true);
            }
            else {
                yield this.exec(`git push --set-upstream ${origin} ${branch}`, true);
            }
            yield this.exec(`git checkout ${status.current}`, true);
            yield this.exec(`git checkout -- .`, true);
            const s = yield this.colorize("green", `Successfully released version ${json.version}`);
            console.log(s);
        });
    }
    checkRepoClean(origin, status) {
        return __awaiter(this, void 0, void 0, function* () {
            const clean = yield this.git_porcelain();
            if (!clean) {
                const message = yield this.colorize("red", `Repository not clean. Please push your local changes to ${origin}/${status.current} first.`);
                console.log(message);
            }
            return clean;
        });
    }
    switchToBranch(status, branch) {
        return __awaiter(this, void 0, void 0, function* () {
            const local = yield this.getLocalBranch(branch);
            if (local) {
                if (!local.current) {
                    yield this.exec(`git checkout ${branch}`, true);
                    const origin = status.tracking.split("/")[0];
                    const remote = yield this.getRemoteBranch(origin, branch);
                    if (remote) {
                        yield this.exec(`git pull ${origin} ${branch}`, true);
                        return;
                    }
                    yield this.exec(`git merge ${status.current} -m "Update to new master"`, true);
                }
            }
            else {
                yield this.exec(`git checkout -b ${branch}`, true);
            }
        });
    }
    getLocalBranch(branch) {
        return __awaiter(this, void 0, void 0, function* () {
            const branches = yield promise_1.default().branch([]);
            return branches.branches[`${branch}`];
        });
    }
    getRemoteBranch(origin, branch) {
        return __awaiter(this, void 0, void 0, function* () {
            const remotes = yield promise_1.default().branch(["--remotes"]);
            return remotes.branches[`${origin}/${branch}`];
        });
    }
};
__decorate([
    billy_core_1.usesPlugins(billy_plugin_core_1.CorePlugin, billy_plugin_git_1.GitPlugin),
    billy_core_1.Command(`Release a version (Used to check in production node_modules. 
        Will be removed once GitHub Actions versioning can be automated)`),
    __param(0, billy_core_1.param(params_1._branch)),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [Object]),
    __metadata("design:returntype", Promise)
], GithubActionsPlugin.prototype, "release", null);
GithubActionsPlugin = __decorate([
    billy_core_1.Plugin("Billy Plugin for Github Actions")
], GithubActionsPlugin);
exports.GithubActionsPlugin = GithubActionsPlugin;
function input(name) {
    return (target, key, index) => {
        var metadataKey = `__input_${key}`;
        if (Array.isArray(target[metadataKey])) {
            target[metadataKey].push({ index: index, key: key, value: name });
        }
        else {
            target[metadataKey] = [{ index: index, key: key, value: name }];
        }
    };
}
exports.input = input;
function GitHubAction() {
    return (target, key, descriptor) => {
        if (descriptor === undefined) {
            descriptor = Object.getOwnPropertyDescriptor(target, key);
        }
        var originalMethod = descriptor.value;
        var metadataKey = `__input_${key}`;
        var inputs = target[metadataKey];
        //editing the descriptor/value parameter
        descriptor.value = function (...args) {
            inputs
                .filter(input => input.key === key)
                .forEach(input => {
                args.splice(input.indey, 0, core.getInput(input.value));
            });
            var result = originalMethod.apply(this, args);
            return result;
        };
        return descriptor;
    };
}
exports.GitHubAction = GitHubAction;
